მასივები ინახავს ელემენტებს მეხსიერების მომიჯნავე ადგილებში, რის შედეგადაც ადვილად გამოსათვლელი მისამართებია შენახული ელემენტებისთვის და ეს საშუალებას აძლევს ელემენტს უფრო სწრაფ წვდომას კონკრეტულ ინდექსზე. დაკავშირებული სიები ნაკლებად ხისტია მათი შენახვის სტრუქტურაში და ელემენტები, როგორც წესი, არ ინახება მომიჯნავე ადგილებში, ამიტომ ისინი უნდა ინახებოდეს დამატებითი ტეგებით, რომლებიც მიუთითებენ შემდეგ ელემენტზე. მონაცემთა შენახვის სქემაში ეს განსხვავება წყვეტს, თუ რომელი მონაცემთა სტრუქტურა იქნება უფრო შესაფერისი მოცემული სიტუაციისთვის.



LinkedList არის მონაცემთა სტრუქტურა, რომელიც შედგება კვანძების თანმიმდევრობისგან, სადაც თითოეული კვანძი ინახავს მითითებას ობიექტზე და მითითებას მიმდევრობის შემდეგ კვანძზე. კვანძები სულაც არ ინახება მეხსიერების მომიჯნავე ადგილებში, როგორც ეს ხდება მასივის შემთხვევაში.

მიმდევრობის პირველ კვანძს LinkedList-ის თავი ეწოდება, ბოლო კვანძს კი კუდი. თითოეულ კვანძს, გარდა კუდისა, აქვს მინიშნება მიმდევრობით მომდევნო კვანძზე. კუდის კვანძს აქვს მინიშნება null-ზე.

LinkedLists ჩვეულებრივ გამოიყენება აბსტრაქტული მონაცემთა ტიპების დასანერგად, როგორიცაა სტეკები, რიგები და სიმბოლოების ცხრილები. ისინი შეიძლება იყოს უფრო მოქნილი ვიდრე მასივები, რადგან ისინი იძლევა ელემენტების ეფექტური ჩასმისა და ამოღების საშუალებას მიმდევრობის ნებისმიერ პოზიციაზე, მაგრამ შეიძლება ნაკლებად ეფექტური იყოს ელემენტებზე შემთხვევითი წვდომისთვის.


//////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////

განსხვავება linked list და list შორის

დაკავშირებულ სიაში, თითოეული ელემენტი (ან "კვანძი") შეიცავს მითითებას სიის შემდეგ ელემენტზე, რომელიც ქმნის ჯაჭვს. ეს ნიშნავს, რომ ელემენტები შეიძლება იყოს გაფანტული მეხსიერებაში და ელემენტზე წვდომის ერთადერთი გზა არის სიის თავიდან გავლა.

ამის საპირისპიროდ, სია პითონში განხორციელებულია, როგორც მეხსიერების მიმდებარე ბლოკი, ელემენტებით ინახება მიმდებარე პოზიციებზე. ეს ნიშნავს, რომ ელემენტებზე წვდომა შესაძლებელია უშუალოდ მათი ინდექსით, მთელი სიის გავლის გარეშე.

აქ არის კიდევ რამდენიმე ძირითადი განსხვავება პითონში დაკავშირებულ სიებსა და სიებს შორის:

ჩასმა და წაშლა: დაკავშირებულ სიაში, სიის შუაში ელემენტის ჩასმა ან წაშლა არის მუდმივი დროის ოპერაცია (თუ ვივარაუდებთ, რომ თქვენ გაქვთ მითითება კვანძზე, რომლის ჩასმა ან წაშლა გსურთ), რადგან თქვენ უბრალოდ უნდა განაახლოთ მიმდებარე კვანძების მითითებები. სიაში, სიის შუაში ელემენტის ჩასმა ან წაშლა მოითხოვს ყველა ელემენტის გადატანას ჩასმის ან წაშლის წერტილის შემდეგ, რაც არის ხაზოვანი დროის ოპერაცია.
შემთხვევითი წვდომა: როგორც აღვნიშნეთ, სიის კონკრეტულ ინდექსზე ელემენტზე წვდომა არის მუდმივი დროის ოპერაცია, ხოლო დაკავშირებულ სიაში, სასურველი ელემენტის საპოვნელად თავიდან უნდა გაიაროთ სია.
მეხსიერების გამოყენება: დაკავშირებული სიები შეიძლება იყოს მეხსიერების უფრო ეფექტური ვიდრე სიები გარკვეულ შემთხვევებში, რადგან ისინი არ საჭიროებენ მეხსიერების მიმდებარე ბლოკს. ამასთან, დაკავშირებულ სიაში თითოეული კვანძი საჭიროებს დამატებით მეხსიერებას მომდევნო კვანძზე მითითების შესანახად, რომელიც შეიძლება დაემატოს, თუ ელემენტების დიდი რაოდენობა გაქვთ.
ზოგადად, თუ თქვენ გჭირდებათ ხშირად შეხვიდეთ ელემენტებზე ინდექსის მიხედვით ან შეასრულოთ ოპერაციები, რომლებიც მოიცავს სიის შუაში ელემენტების ჩასმას ან წაშლას, სია შეიძლება იყოს უკეთესი არჩევანი. თუ საჭიროა სიის დასაწყისში ან ბოლოს ელემენტების ხშირად ჩასმა ან წაშლა, ან თუ წინასწარ არ იცით სიის ზომა და გსურთ თავიდან აიცილოთ მეხსიერების წინასწარ განაწილება, დაკავშირებული სია შეიძლება იყოს უკეთესი არჩევანი.








class Node:
    def __init__(self, data=None, next=None):
        self.data = data
        self.next = next

# ეს პირველი კლასი წარმოადგენს ცალკეულ ელემენტებს ჩვენს სიაში
# data ნიშნავს ნებისმიერი სახის ინფორმაციას და next არის მიმთითებელი შემდეგ ელემენტზე


class LinkedList:
    def __init__(self):
        self.head = None # მიუთითებს სიის სათავეს

    def insert_at_beginning(self, data):
        node = Node(data, self.head) # ანუ შემდეგი ელემენტი იქნება ეს head
        self.head = node # და ანუ ეხლა ეს ჩვენი head იქნება ნოუდი და რავი ალბათ ეგრე მიყვება რა

    def print(self):
        if self.head is None:
            print("Linked List is empty")
            return

        itr = self.head
        llstr = ''

        while itr:
            llstr += str(itr.data) + '-->'
            itr = itr.next

        print(llstr)




# ანუ ეს პრინტავს იმ ყველა მომდევნო მონაცემს თავში ანუ ეხლა 5 არის ბოლო
if __name__ == '__main__':
    ll = LinkedList()
    ll.insert_at_beginning(5)
    ll.insert_at_beginning(10)
    ll.insert_at_beginning(13)
    ll.print()



ეს იმისთვის რომ თანმიმდევრობით მივაყოლო

    def insert_at_end(self, data):
        # ანუ თუ არაფერია ჰეადში მაშინ მინდა რომ ახალ ახალი ელემენტები დაემატოს ბოლოში ანუ ბოლოებს არ ყავთ გამგრძელებელი
        if self.head is None:
            self.head = Node(data, None)
            return

        # ანუ აქ ელემენტებს ვსვავთ ბოლოში
        itr = self.head
        while itr.next:  # ანუ თუ ნექსთ არის არაფერი მაშინ მინდა რომ გავაგრძელო სანამ არ გახდება არაფერი
            itr = itr.next

        # და მაგის შემდეგ როდესაც უკვე ბოლოში ვართ მინდა რომ ჩავსვა ელემენტი რომლიც იქნება ბოლო ანუ ნექსთ ელემენტი ამას არ აქვს
        itr.next = Node(data, None)


ეს უკვე იმისთვის მაგალითად რაიმე ლისტი რომ ჩავსვათ ან ასშ...

    def insert_values(self, data_list):
        self.head = None
        for data in data_list:
            self.insert_at_end(data)

რათქმაუნდა ეს ყველაფერი ერთ კლასში მაქ

//////////////////////////////////////////////////////////////

გავიგოთ რამდენი ელემენტი გვაქ ლისტში
    def length(self):
        count = 1
        itr = self.head
        while itr.next:
            count += 1
            itr = itr.next
        return count


//////////////////////////////////////////////////////////////


ვშლით ელემენტს
    def remove_at(self, index):
        if index<0 or index > self.length():
            raise Exception('Invalid index')

        if index == 1: # ანუ ჩვენ აქ ვცდილობთ წავშალოთ ჰეადი ასერომ ჰეადი გახდება შემდეგი ელემენტი
            self.head = self.head.next
            return

        count = 1
        itr = self.head
        while itr.next:
            if index-1 == count:
                itr.next = itr.next.next
                break
            itr = itr.next
            count += 1


///////////////////////////////////////////////////////////////

ვსვავთ ელემენტებს რომელიმე ინდექსზე რომელიც ჩვენ გვინდა

    def insert_at(self, index, data):
        if index < 0 or index > self.length():
            raise Exception('Invalid index')

        if index == 0:
            self.insert_at_beginning(data)
            return

        count = 0
        itr = self.head
        while itr:
            if index-1 == count:
                node = Node(data, itr.next) ანუ აქ რაღაცნაირად შუაში ვხტებით ელემენტების ანუ თუ ვუთითებთ ინდექსს 1 მაშინ 0 და 2 შუაში ჩავხტებით ესეიგი 1 ელემენტი გახდება მეორე და ასშ
                itr.next = node
                break

            itr = itr.next
            count += 1


///////////////////////////////////////////////////////////////

ანუ აქ არის ასეთი რამ რა

ll.insert_after_value("vinme4", "Gocha")

ანუ vinme4 ის შემდეგ დაამატებს Gochaს

    def insert_after_value(self, data_after, data_to_insert):
        if self.head is None:
            return

        itr = self.head
        while itr:
            if data_after == itr.data:
                node = Node(data_to_insert, itr.next)
                itr.next = node
                break

            itr = itr.next
        else:
            print(f"Given data {data_after} is not in list")


///////////////////////////////////////////////////////////

ვშლით მნიშვნელობის მიხედვით

    def remove_by_value(self, data):
        if self.head is None:
            return

        if data == self.head.data:
            self.head = self.head.next

        itr = self.head
        while itr:
            if itr.next.data == data: # აქ არვიცი რამოხდა უბრალოდ იყოს ესეა
                itr.next = itr.next.next
                break
            itr = itr.next
