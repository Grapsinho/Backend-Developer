კლასი გამოიყენება ახალი ტიპის ობიექტის აღსაწერად ხოლო ობიექტი არის მონაცემები რომლებიც მიეკუთვნებიან რაღაც კლასს ხოლო პითონში არსებული ტიპები წარმოადგენს კლასს


მონაცემთა აბსტრაქცია გულისხმობს მონაცემთა ინკაფსულაციასა და გარკვეული ინფორმაციის დამალვას ერთდროულად

ინკაფსულაცია ნიშნავს მონაცემების შეკვრას მეთოდების გამოყენებით

ინფორმაციის დამალვა ეს არის მიდგომა რომლის დროსაც კლასის გარეთ დამალულია გარკვეული სახის მონაცემი ასერომ მათი შეცვლა კლასის გარეთ არ შეგვიძლია

///////////////// აბსტრაქცია/////////////////////
აბსტრაქცია არის მიდგომა როდესაც მომხმარებელი ინფორმაცირებულია თუ როგორ მუშაობს კონკრეტული სისტემა, და არ არის საჭირო მან იცოდეს ყვლეაფერი დეტალურად თუ რა ნაწილებისგან შედგება იგი ანუ სხვა ყველაფერი რომელიც არარის მომხმარებლისთვის მნიშვნელოვანი დამალულია.

///////////////// ინკაფსულაცია/////////////////////
ეს გულისხმობს გარკვეული ნიშნით დაკავშირებული მონაცემების თავმოყრას ერთ გარემოში, როგორც ერთიანი სისტემა კლასები ამის კარგი მაგალითია. getter setter მეთოდებით მიიღწევა ინკაფსულაცია.

///////////////// ინფორმაციის დამალვა/////////////////////
ეს გულისხმობს რომ კლასის გარეთ ზოგიერთი ცვლადები და მეთოდები არუნდა იყოს წვდომადი რათა არ მოხდეს მათი შემთხვევითი ცვლილება

///////////////polymopishm///////////////
ანუ ეს და inheritance თითქმის გავს ერთმანეთს ანუ ეს არის როდესაც ერთი რაღაც ინტერფეისი მოგვაქ განსხვავებული ტიპის კლასებისთვის მაგალითად. ანუ თუ გვაქ რაღაც ფერი მეთოდი შეგვიძლია ის გადმოვიტანოთ სხვა კლასში და უბრალოდ ჩვენებურად დავადეტალიზიროთ მაგალთად შევუცვალოთ უბრალოდ ფერი და ასშ.

///////////////// property()/////////////////////

ეს მეთდი შეიცავს getter setter და deleter მეთოდებს რომლის მეშვეობითაც ხდება კლასის ცვლადებზე მუშაობა
მოკლედ ამ ფუნქციას ვიძახებთ კლასის შიგნით ანუ მაგალითად ვარქმევთ რამე სახელს name = property(getter,setter,deleter) ანუ თუ გამოვიძახებთ ამ მეთოდს 

ესეიგი print(obj1.name) ამდროს ამუშავდება getter მეთოდი და გამოიძახება იგი
obj1.name = "rame" ამდროს ამუშავდება setter მეთოდი
del obj1.name ამდროს ამუშავდება deleter მეთოდის

////////////////dir,help,__doc__/////////////////////
dir ფუნქცია აბრუნებს პარამეტრად გადაცემული ობიექტის ატრიბუტებისა და მეთოდების ჩამონათვალს
print(dir(obj1))

help ფუნქცია აბრუნებს ატრიბუტებისა და მეთოდების ჩამონათვალს თავისი აღწერილობით

__doc__ რაღაც დოკსტრინგს გვიბრუნებს რა არცვიცი რა არის ეგ ნორმალურად ანუ ჩვენი კლასის აღწერა მგონი

კლასის სახელი.__dict__  გვიბრუნებს ამ კლასში არსებულ ყველა key value ეს მგონი ობიექტს უნდა მივუთითოთ

//////////////class method////////////////////
ესეიგი ეს არის მეთოდი რომელიც უკავშირდება კლასს და არა მის ობიექტს ანუ მას დიდად არ სჭირდება კლასის ობიექტის შექმნა
ის ყოველთვის მუშაობს კლასთან ერთად რადგან მისი პარამეტრი არის ყოველთვის თვითონ კლასი
რომელ მეთოდსაც შევქმნით ამით იმას არ დაჭირდება ცალკე ობიექტის შექმნა გამოსაძახებლად


from datetime import date

# random Person
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    @classmethod
    def fromBirthYear(cls, name, birthyear):
        return cls(name, date.today().year - birthyear)

    def display(self):
        print(self.name + "'s age is: " + str(self.age))

person1 = Person.fromBirthYear('John',  1985)
person1.display()



////////////////////////////////////////////////////////////////////////////////


/////////////////static method//////////////////
ანუ ამით ჩვენ ძირითადად ვართ დაკავშირებული კლასთან და არა ობიექტთან ანუ ჩვენ არ შეგვიძლია ობიეტის ცვლადებზე მანიპულირება


///////////////issubclass///////////////
გვიჩვენებს მემკვიდრეებს    issubclass(Man, Person) ანუ აქ Man არის Person ის მემკიდრე ანუ Person არის მშობელი კლასი და ჩვენ მისი რაღაცეები გადავეცით Manს
ესეიგი ეს დაბეჭდავს trueს

///////////////isinstance///////////////
ininstance() ფუნქცია აბრუნებს True-ს, თუ მითითებული ობიექტი არის მითითებული ტიპის, წინააღმდეგ შემთხვევაში False.
 
class costumer:
    
    შევქმენით ინიციალიზაციის მეთოდი რათა ატრიბუტებს გავუწიო ინიციალიზაცია
    def __init__(self, firstName, lastName, age):
        self.firstName = firstName
        self.lastName = lastName
        self.age = age

user_01 = costumer("Giorgi", "Giguashvili", 16)

print(user_01.firstName, user_01.lastName, user_01.age)

ასე ვქმნით კლასებს


class costumer:
    def __init__(self, firstName, lastName, age):
        self.firstName = firstName
        self.lastName = lastName
        self.age = age

    def rename(self, name):
        self.firstName = name


user_01 = costumer("Giorgi", "Giguashvili", 16)

user_01.rename("Dato")

print(user_01.firstName)

ასე ვცვლით ან შეგვიძლია შევცვალოთ

class costumer:
    def __init__(self, firstName, lastName, age):
        self.firstName = firstName
        self.lastName = lastName
        self.age = age

    def rename(self, name):
        self.firstName = name

    def info(self):
        print(f"Costumer Full Info: {self.firstName} {self.lastName}")
        print(f"Costumer Age: {self.age}")


user_01 = costumer("Giorgi", "Giguashvili", 16)

user_01.info()

ესე კიდე შეგვიძლია ნუ რაღაცეები დავბეჭდოთ რა

მოკლედ ეს უნდა დავამატოთ ჩვენს კლასში
objects = []

ხოლო შემდეგ initში ვაკეთებთ ასეთ რამეს და ასეროომვთვათ ვქმნით ლისტს თუ გვაქ ორი ან მეტი იუზერი
costumer.objects.append(f"{self.firstName} {self.lastName}")

print(costumer.objects)


შევქმენი აიდი კლასში
ID = 0

გადავეცი ინიციალიზაციას რავი მგონი ეგრეა 
self.id = costumer.ID
შევიტანი ჩვენს ობიექტში
costumer.objects.append(f"ID {self.id} --> {self.firstName} {self.lastName}")
გავზარდე ერთი ანუ ვითვლი იუზერებს ამით
costumer.ID += 1

//////////////////////////////////////////////////////////////////////

def __repr__(self):
    return f"Costumer Full Info: {self.firstName} {self.lastName}"

ესეიგი რავქენით ეხლა ჩვენ

ეგრევე რო გამოვიძახოთ ეს ჩვენი იუზერები user_01 user_02 დაგვიბეჭდავს ამას თუ ეს არ გვინდა მაშ გამოვიყენებთ რეპრეზენტაცია 
<__main__.costumer object at 0x0000016669665B10>




Inheritance მემკვიდრეობა


ჩვ შევქმენით პირველი კლასი
class car:
    def __init__(self, model, year):
        self.model = model
        self.year = year
        აქ დისტანცია მივუთითე ნული ეს შეგვიძლია იმის გათვალისწინებით რომ პარამეტრებში არგვაქ
        self.distance = 0

    def get_info(self):
        print(f"Car Full Info: {self.model} {self.year}")

     ხოლო ამ ფუნქციით შეგვიძლია დავამატოთ დისტანციის მნიშვნელობა
    def set_distance(self, distance):
        if self.distance >= distance:
            print("less distance")
        else:
            self.distance = distance

car_1 = car("Mercedes", 2000)

ხოლო აქ გამოვიყენეთ მემკვიდრეობა
class eCar(car):
    def __init__(self, model, year):
        ეს რაღაც გვჭირდება ამისთვის იქარის ინიციალიზაციას უნდა სელფ ამას არა და ეს წამოიღებს ყველაფერს რაც არის პირველ კლასში ზუსტად იგივე იქნება
        super().__init__(model, year)

car_2 = eCar("BMW", 2007)
და აი აქ შევცვალეთ დისტანცია
car_1.set_distance(150)

ანუ ეხლა დისტანცია არის 150 ნულის მაგივრად
print(car_1.distance)


private variable იქმნება ასე __და სახელი