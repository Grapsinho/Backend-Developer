///////////////////////////////////////////////////////
//////////////////// Django Channels ///////////////////
///////////////////////////////////////////////////////
Django Channels რომელიც ეხმარება ჯანგოს რომ დაამუშავოს რეალურ დროში ასინქრონული საკომუნიკაციო პროტოკოლები როგორიცაა WebSockets და ასშ...

ეს საშუალებას გვაძლევს რომ დავწეროთ კოდი რომელიც რეაგირებს მოვლენებსა და განახლებებზე რეალურ დროში ისე რომ იუზერს არ ჭირდება საიტის განახლება.

Django Channels ეს არის დაშენებული ASGIზე რომელიც საშუალებას აძლევს ჯანგოს რომ გაუმკლავდეს ასინქრონულ მოთხოვნებს და პასუხებს ანუ როდესაც ვიყენებთ HTTPს მაშინ ჩვენ ვიყენებთ WSGI რომელიც თავის მხრივ გვაკავშირებს ჩვენს django viewsებთან ანუ პირველ რიგში გადავდივართ ლინკზე და შემდეგ ვუკავშირდებით ამ views ან როგორღაც რა

channels: ეს არის ინტერფეისი რომელიც ამუშავებს დაბალი დონის ფუნქციებს, როგორიცაა კავშირების გახსნა და დახურვა, შეტყობინებების გაგზავნა და მიღება, არხებისა და ჯგუფების მართვა.

///////////////////////////////////////////////////////
////////////////////// WebSockets//////////////////////
///////////////////////////////////////////////////////

ეს არის პროტოკოლი რომელიც საშუალებს იძლევა რომ კლიენტმა და ვებსერვერმა იკომუნიკაციონს რეალურ დროში. განსხვავებით HTTP სგან რომელიც არის მოთხოვნა-პასუხის პროტოკოლი, WebSockets არის ორმხრივი ეს იმას ნიშანვს რომ როგორც იუზერს ასევე სერვერსაც შეუძლია საუბრის დაწყება. WebSockets გამოიყენება ისეთი აპლიკაციებისთვის რომლებიც საჭიროებენ რეალურ დროში განახლებებს როგორიცაა მაგალითად ჩატის სისტემა

ანუ როდესაც ჩვენ მესიჯს ვგზავნით რაღაც ჯგუფში ამდროს სერვერი იწყებს საუბარს და უგზავნის იმ მესიჯს რაც ჩვენ გავგზავნეთ ყველას, როდესაც სერვერს მესიჯი მიუვა ის მაშინვე გაგზავნის მათ სხვებთან.


ტრადიციული მოთხოვნა-პასუხის ცილკი:

როდესაც შედიხარ ვებსაიტზე შენი ბრაუზერი აგზავნის მოთხოვნას სერვერთან და სერვერიც პასუხობს მას, ეს კარგია მაგრამ არის რაღაცეები რისი გაკეთებაც ამით არ არის სახარბიელო მაგალითად ჩათ აპლიკაციის და ასშ...

მოკლედ ვებსოქეთი გვაძლევს გამოსავალს ამასთან გამკლავებაში, ვებსოქეთი აყალიბებს მუდმივ კავშირს კლიენტსა და სერვერს შორის, ეს ნიშნავს რომ კლიენტს და სერვერს შეუძლიათ იურთიერთონ რეალურ დროში


როგორ მუშაობს ვებსოქეთი:

პროცესი იწყება ხელის ჩამორთმევით(Handshake), კლიენტი აგზავნის HTTP მოთხოვნას სერვერთან ანუ ამით ის ასერომვთქვათ სურვილს გამოხატავს რომ თავისი კავშირი ვებსოქეთ კავშირზე გადაიყვანოს


//////////////////////////////////////////////////////
////////////////////////Redis/////////////////////////
//////////////////////////////////////////////////////

მოკლედ რედისი გამოიყენება მესეჯ ბროკერად ასერომვთქვათ ის არის შუა კაცი მასთან მიდის მესიჯი და ის უზრუნველყოფს რომ მესიჯმა მიაღწიოს დანიშნულების ადგილს

მაგ: იუზერმა გაგზავნა მესიჯი ჩატში --> მიიღო ეს მესიჯი რედისმა --> და გაგზავნა სწორ ადგილას კონსუმერ ფაილში


გამგზავნი (პროდიუსერი):

აქედან იწყება შეტყობინება. ეს შეიძლება იყოს თქვენი განაცხადის ნაწილი, რომელსაც სურს ინფორმაციის გაგზავნა.

შეტყობინებების ბროკერი (Mailman):

შეტყობინებების ბროკერი ფოსტალიონს ჰგავს. ის იღებს შეტყობინებას გამგზავნისგან და უზრუნველყოფს მის სწორ დანიშნულებამდე მისვლას.

მიმღები (მომხმარებელი):

აქ მთავრდება შეტყობინება. ეს შეიძლება იყოს თქვენი განაცხადის სხვა ნაწილი, რომელიც საჭიროებს ინფორმაციის მიღებას და დამუშავებას.


pip install channels-redis


# settings.py

CHANNEL_LAYERS = {
    "default": {
        "BACKEND": "channels_redis.core.RedisChannelLayer",
        "CONFIG": {
            # The URL scheme to use for the Redis connection (defaults to redis://)
            "hosts": [("localhost", 6379)],
        },
    },
}


asgi file
from django.urls import re_path
from channels.auth import AuthMiddlewareStack
from channels.routing import ProtocolTypeRouter, URLRouter
from django.core.asgi import get_asgi_application
import myapp.routing  # Import your app's routing module

application = ProtocolTypeRouter({
    'http': get_asgi_application(),
    'websocket': AuthMiddlewareStack(
        URLRouter(
            myapp.routing.websocket_urlpatterns
        )
    ),
})


//////////////////////////////////////////////////////
//////////////////////გამოყენება/////////////////////
//////////////////////////////////////////////////////

მოკლედ როგორც ჩვეულებრივი httpსთვის ვაკეთებთ ხოლმე ურლს და რაღაცეებს ისე უნდა გავაკეთოთ აქაც

routing = url
consumer = views

ესეიგი როდესაც ყველაფერს შევქმნთ შემდეგ უნდა გადმოვწეროთ
python -m pip install -U channels ვიწერთ ამას და სეთინგებში ვამატებთ ინსტალედ აპპებში channels ესე

შემდეგ ჩვენს მთავარ ფოლდერში ვქმნით routing.py ფაილს 

3.0.5

